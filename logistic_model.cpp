//
//  logistic_model.cpp
//  SP_SVM
//
//  Created by Gabriel Hope on 9/26/14.
//
//

#include "logistic_model.h"

namespace lasp {
	
//	template<class T, class N>
//	Logistic<T, N>::Logistic() {
//		options().C = 0;
//	}
//	
//	template<class T, class N>
//	Logistic<T, N>::Logistic(opt opt_in) {
//		options() = opt_in;
//	}
//	
//	template<class T, class N>
//	LaspMatrix<T> Logistic<T, N>::get_hyp(){
//		LaspMatrix<T> out = options().C;
//		return out;
//	}
//	
//	template<class T, class N>
//	vector<string> Logistic<T, N>::get_hyp_labels(){
//		vector<string> out;
//		out.push_back("C");
//		return out;
//	}
//	
//	template<class T, class N>
//	int Logistic<T, N>::set_hyp(LaspMatrix<T> hyp){
//		options().C = hyp(0);
//	}
//	
//	template<class T, class N>
//	int Logistic<T, N>::train(LaspMatrix<T> X, LaspMatrix<N> y){
//		
//		return 0;
//	}
//	
//	template<class T, class N>
//	int Logistic<T, N>::predict(LaspMatrix<T> X, LaspMatrix<N>& output) {
//		return 0;
//	}
//	
//	
//	int confidence(LaspMatrix<T> X, LaspMatrix<T>& output);
//	int predict_confidence(LaspMatrix<T> X, LaspMatrix<T>& output_predictions, LaspMatrix<T>& output_confidence);
//	int distance(LaspMatrix<T> X, LaspMatrix<T>& output);
//	
//	T score(LaspMatrix<T> y_pred, LaspMatrix<T> y_actual);
//	T loss(LaspMatrix<T> y_prob, LaspMatrix<T> y_actual);
//	T loss(LaspMatrix<T> y_pred, LaspMatrix<T> y_prob, LaspMatrix<T> y_actual);
//	
//	T test(LaspMatrix<T> X, LaspMatrix<T> y);
//	T test_loss(LaspMatrix<T> X, LaspMatrix<T> y);
	
	
}